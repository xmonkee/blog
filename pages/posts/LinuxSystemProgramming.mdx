import { withRouter } from 'next/router'
import BlogPost from '../../components/layouts/blog-post'

export const meta = {
  published: true,
  publishedAt: '2018-07-15',
  title: 'Linux System Programming by Robert Love',
  summary: 'Reading Notes',
  image: '/static/site-feature.png',
}

export default withRouter(({ children, router }) => (
  <BlogPost path={router.pathname} meta={meta}>
    {children}
  </BlogPost>
))

#### Chapter 1 - Introduction

- processes inherit the UID and GID
- permission octal values: r=4, w=2, x=1. Order is user, group, everyone else
- functions normally just return a -1 to indicate an error
- more details to be found in `extern int errno` in `<errno.h>`
- to print `void perror(const char *str)` in `<stdio.h>`
- example:

```c
if (close (fd) == −1)
        perror ("close");
```

#### Chapter 2 - File I/O

- Opening files: 
```c
fd = open(<path>, flags)
```
- create: 
```c
fd = open (file, O_WRONLY | O_CREAT | O_TRUNC, 0664);
```
- is identical to 
```c
fd = creat (filename, 0644);
```
- fd of -1 indicates error
- reading:
```c
#include <unistd.h>
ssize_t read (int fd, void *buf, size_t len);
```
- A call to read() can result in many possibilitie, to read all the bytes
```c
ssize_t ret;
while (len != 0 && (ret = read (fd, buf, len)) != 0) {
  if (ret == −1) {
    if (errno == EINTR)
      continue;
    perror ("read");
    break;
  }
  len -= ret;
  buf += ret;
}
```
- nonblocking reads can be achieved by passing O_NONBLOCK to `open`
- if a read is blocked, it will return -1 and errno will be set to EAGAIN
- write:
```c
#include <unistd.h>
ssize_t write (int fd, const void *buf, size_t count);
```
- call fsync(int ft) to sync writes to storage
- fdatasync(int fd) does the same thing, without updated metadata, and is faster
- use the O_SYNC flag to always sync
- closing:
```c
#include <unistd.h>
int close(int fd)`
```
- seeking:
```c
#include <sys/types.h>
#include <unistd.h>
off_t lseek (int fd, off_t pos, int origin);
```
- you CAN seek past the end of a file, it will be padded with zeros
- position reads and writes avoid the race condtion associated with seeking and then reading
```c
#define _XOPEN_SOURCE 500
#include <unistd.h>
ssize_t pread (int fd, void *buf, size_t count, off_t pos);
ssize_t pwrite (int fd, const void *buf, size_t count, off_t pos);
```
##### Multiplexed IO
- `poll()` is easier to use than `select()`
- both wait on a set of open file descriptors and return when any are available
- poll example
```c
#include <stdio.h>
#include <poll.h>
#include <unistd.h>

int main(int argc, char **argv)
{
		struct pollfd fds[2];
		fds[0].fd = STDIN_FILENO;
		fds[0].events = POLLIN;
		
		fds[1].fd = STDOUT_FILENO;
		fds[1].events = POLLOUT;

		int err = poll(fds, (nfds_t) 2, 0);
		if (err == -1) {
			perror("poll");
			return -1;
		}
		
		if (fds[0].revents & POLLIN) {
			printf("STDIN ready\\n");
		}
		if (fds[1].revents & POLLOUT) {
			printf("STDOUT ready\\n");
		}
		
		return 0;
}
```
- The VFS provides a unified blocks and inodes based interface to all filesystems
- The page cache holds retrieved info including readaheads

### Chapter 3 - Buffered I/O
- Usually more efficient to read in multiples of 4096 or 8192 bytes because of block alignment
- User space buffered IO can increase performance even more
- Write to a buffer, which is written in a single operation
- The read requests are served from the buffer
- The end result is fewer system calls for larger amounts of data, all aligned on block boundaries.
- Provided by `stdio`
- StardardI/O routines act on file pointers, not fds
- `FILE` type defined in `stdio.h`
```c
FILE * fopen (const char *path, const char *mode);
FILE * fdopen (int fd, const char *mode);
```
- modes: r, w, r+ (read+write), w+ (read, write, truncates), a+(rw in append mode)
- Closing the stream will close the file descriptor as well.
```c
int fclose (FILE *stream);
int fcloseall (void); // Linux specific
```
- reading
```c
// read a char
int fgetc (FILE *stream); 
// put it back
int ungetc (int c, FILE *stream); 
// read a line
// reads one char less than size and puts a \0 at the end
// will stop and newline and also put a \n
char * fgets (char *str, int size, FILE *stream); 
// Read binary data
// reads `nr` elements, each of size `size`
// returns less than nr if there's an error
// it is impossible to know which of the two conditions occurred without using ferror() and feof()
size_t fread (void *buf, size_t size, size_t nr, FILE *stream);
```
- writing
```c
// write a char
// return EOF in case of error
int fputc (int c, FILE *stream);
// write a string
int fputs (const char *str, FILE *stream);
// binary
// A return value less than nr denotes error.
size_t fwrite (void *buf, size_t size, size_t nr, FILE *stream);
```
- It’s important to bear in mind that because of differences in variable sizes, align‐
ment, and so on, binary data written with one application may not be readable by other
applications.
- Example program
```c

# include <stdio.h>

int main(int arc, char **argv) {
	struct pirate {
			char name[100];
			unsigned long booty;
			unsigned int beard_len;
	} p, blackbeard = {"Mayank", 100, 50};
	
	FILE * file = fopen("/tmp/pirate", "w");
	if (!file) {
		perror("fopen");
		return 1;
	}
	if(!fwrite(&blackbeard, sizeof (struct pirate), 1, file)){
		perror("fwrite");
		return 1;
	}
	if(fclose(file)) {
		perror("fclose");
		return 1;
	}

	file = fopen("/tmp/pirate", "r");
	if (!file) {
		perror("fopen");
		return 1;
	}
	if(!fread(&p, sizeof(struct pirate), 1, file)) {
		perror("fread"); return 1;
	}
	if(fclose(file)) {
		perror("fclose");
		return 1;
	}
	printf("%s, %lu, %u", p.name, p.booty, p.beard_len);
}
```
- other
```c
int fseek (FILE *stream, long offset, int whence);
fsetpos, rewind, ftell, fgetpos
fflush flushes the data to the kernel
fileno(*stream) gets the fd
```
- errors
```c
ferror(FILE *stream) returns non-zero if error is set
feof() returns nonzero if EOF is set
clearerr() clears the error
```
##### Threading
- Standard io functions are thread safe
- For multipel functions, use explicit locks
```c
flockfile(*stream) locks a file (blocking) by incrementing lock count
funlockfile(*stream) decrements lock count
ftrylockfile(*stream) is non-blocking, returning nonzero if cannot lock
```